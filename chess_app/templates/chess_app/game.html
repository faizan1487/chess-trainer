{% extends 'chess_app/base.html' %}
{% load static %}

{% block title %}{{ opening.name }} Training{% endblock %}

{% block extra_css %}
<style>
    .chessboard {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
    }
    .move-history {
        height: 300px;
        overflow-y: auto;
    }
    .move-row {
        display: flex;
        margin-bottom: 5px;
    }
    .move-number {
        width: 30px;
        font-weight: bold;
    }
    .white-move, .black-move {
        flex: 1;
        padding: 0 5px;
    }
    .white-move {
        background-color: #f8f9fa;
    }
    .black-move {
        background-color: #e9ecef;
    }
    .chat-container {
        height: 400px;
        display: flex;
        flex-direction: column;
        background-color: #f9f9f9;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .chat-messages {
        flex: 1;
        overflow-y: auto;
        border: 1px solid #dee2e6;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 10px;
        background-color: #ffffff;
    }
    .chat-input {
        display: flex;
        border-top: 1px solid #dee2e6;
        padding: 10px;
        background-color: #f1f1f1;
        border-radius: 0 0 10px 10px;
    }
    .chat-input input {
        flex: 1;
        margin-right: 10px;
        border-radius: 20px;
        border: 1px solid #ccc;
        padding: 10px;
    }
    .ai-message, .user-message {
        margin-bottom: 10px;
        padding: 10px 15px;
        border-radius: 20px;
        max-width: 80%;
        transition: all 0.3s ease;
    }
    .ai-message {
        background-color: #e0f7fa;
        align-self: flex-start;
        text-align: left;
        margin-right: auto;
    }
    .user-message {
        background-color: #c8e6c9;
        align-self: flex-end;
        margin-left: auto;
        text-align: right;
    }
    .feedback-container {
        margin-top: 20px;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
        background-color: #f8f9fa;
    }
    /* New styles for move analysis display */
    .best-move {
        color: #28a745;
        font-weight: bold;
    }
    .excellent-move {
        color: #20c997;
        font-weight: bold;
    }
    .good-move {
        color: #17a2b8;
    }
    .inaccuracy-move {
        color: #ffc107;
    }
    .mistake-move {
        color: #fd7e14;
    }
    .blunder-move {
        color: #dc3545;
        font-weight: bold;
    }
    .normal-move {
        color: #6c757d;
    }
    .move-quality-indicator {
        display: inline-block;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 5px;
    }
    .move-analysis {
        margin-top: 10px;
        padding: 10px;
        background-color: #f8f9fa;
        border-left: 4px solid #ccc;
        font-size: 0.9rem;
    }
    .improvement-suggestion {
        margin-top: 10px;
        padding: 10px;
        background-color: #fff3cd;
        border-left: 4px solid #ffc107;
        font-size: 0.9rem;
    }
    .progress-container {
        margin-bottom: 15px;
    }
    .progress-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
    }
    /* Typing indicator for AI responses */
    .typing-indicator {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    .typing-indicator span {
        height: 8px;
        width: 8px;
        margin: 0 2px;
        background-color: #9E9EA1;
        display: block;
        border-radius: 50%;
        opacity: 0.4;
        animation: typing 1s infinite;
    }
    .typing-indicator span:nth-of-type(1) {
        animation-delay: 0s;
    }
    .typing-indicator span:nth-of-type(2) {
        animation-delay: 0.2s;
    }
    .typing-indicator span:nth-of-type(3) {
        animation-delay: 0.4s;
    }
    @keyframes typing {
        0%, 100% {
            opacity: 0.4;
            transform: scale(1);
        }
        50% {
            opacity: 1;
            transform: scale(1.2);
        }
    }
    .move-label.badge { margin-left: 8px; margin-right: 8px; font-size: 0.85em; }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <h1>{{ opening.name }} <small class="text-muted">{{ opening.eco_code }}</small></h1>
        <p>{{ opening.description }}</p>
        {% if progress %}
        <div class="progress-container">
            <div class="progress-label">
                <span>Opening Mastery</span>
                <span>{{ progress.mastery_level }}%</span>
            </div>
            <div class="progress">
                <div class="progress-bar bg-success" role="progressbar" 
                     style="width: {{ progress.mastery_level }}%" 
                     aria-valuenow="{{ progress.mastery_level }}" aria-valuemin="0" aria-valuemax="100">
                </div>
            </div>
        </div>
        {% endif %}
    </div>
</div>

<div class="row">
    <!-- Chess Board Column -->
    <div class="col-md-6">
        <div class="card mb-4">
            <div class="card-header">
                <h5>Chess Board</h5>
            </div>
            <div class="card-body">
                <div id="game-board" class="chessboard"></div>
                <!-- Feedback container for move analysis (moved here) -->
                <div id="feedback-container" class="feedback-container d-none"></div>
                <div class="mt-3 text-center">
                    <button id="flip-board" class="btn btn-secondary">Flip Board</button>
                    <button id="reset-game" class="btn btn-warning">Reset Game</button>
                    <button id="hint-button" class="btn btn-info">Hint</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Analysis & Chat Column -->
    <div class="col-md-6">
        <!-- Move History -->
        <div class="card mb-4">
            <div class="card-header">
                <h5>Move History</h5>
            </div>
            <div class="card-body">
                <div id="move-history" class="move-history">
                    <!-- Move history will be populated here -->
                </div>
            </div>
        </div>
        <!-- AI Chat -->
        <div class="card">
            <div class="card-header">
                <h5>Chat with Chess Trainer</h5>
            </div>
            <div class="card-body">
                <div class="chat-container">
                    <div id="chat-messages" class="chat-messages">
                        <div class="ai-message">
                            Hello! I'm your chess trainer. I'll guide you through the {{ opening.name }} opening.
                            Feel free to ask questions about the opening or your moves.
                        </div>
                    </div>
                    <div class="chat-input">
                        <input type="text" id="chat-input" class="form-control" placeholder="Type your question here...">
                        <button id="send-message" class="btn btn-primary">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    $(document).ready(function() {
        // Game data from server
        const gameId = {{ game.id }};
        const openingId = {{ opening.id }};
        const initialFen = "{{ game.fen_position }}";
        const userColor = "{{ game.user_color }}";
        
        // Initialize game state
        let board = null;
        let game = new Chess(initialFen);
        // Only track whose turn it is
        let userTurn = (userColor === 'white' && game.turn() === 'w') || 
                       (userColor === 'black' && game.turn() === 'b');
        
        // Board configuration with local static piece images
        const config = {
            position: initialFen,
            draggable: true,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            orientation: userColor === 'black' ? 'black' : 'white',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        };
        
        // Initialize the board
        board = Chessboard('game-board', config);
        
        // Check if the game is already over when loading the page
        checkGameOver();
        
        // If it's AI's turn initially, request a move
        if (!userTurn && !game.game_over()) {
            setTimeout(getAIMove, 1000);
        }
        
        // Handle piece drag start
        function onDragStart(source, piece) {
            // Don't allow dragging if the game is over
            if (game.game_over()) return false;
            
            // Only allow the current player to move pieces
            if ((userColor === 'white' && piece.search(/^b/) !== -1) ||
                (userColor === 'black' && piece.search(/^w/) !== -1)) {
                return false;
            }
            
            // Only allow user to move on their turn
            if (!userTurn) {
                return false;
            }
        }
        
        // Handle piece drop
        function onDrop(source, target) {
            const position_before = game.fen(); // Capture it
            
            let move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Always promote to queen
            });
            
            if (move === null) return 'snapback';
        
            sendMoveToServer(move, position_before); // <-- PASS IT!
            
            userTurn = false;
            checkGameOver();
        }
        
                
        // Function to check if the game is over and display appropriate message
        function checkGameOver() {
            if (game.game_over()) {
                let message = "";
                if (game.in_checkmate()) {
                    message = game.turn() === 'w' ? "Black wins by checkmate!" : "White wins by checkmate!";
                } else if (game.in_stalemate()) {
                    message = "Game drawn by stalemate!";
                } else if (game.in_threefold_repetition()) {
                    message = "Game drawn by threefold repetition!";
                } else if (game.insufficient_material()) {
                    message = "Game drawn due to insufficient material!";
                } else if (game.in_draw()) {
                    message = "Game drawn by 50-move rule!";
                }
                
                if (message) {
                    // Display game over message in chat
                    $('#chat-messages').append(`<div class="ai-message system-message"><strong>Game Over:</strong> ${message}</div>`);
                    $('#chat-messages').scrollTop($('#chat-messages')[0].scrollHeight);
                    
                    // Also display in feedback container
                    $('#feedback-container').removeClass('d-none').html(`
                        <div class="alert alert-info">
                            <strong>Game Over:</strong> ${message}
                            <button id="new-game" class="btn btn-primary btn-sm ms-3">Start New Game</button>
                        </div>
                    `);
                    
                    // Add event listener for the new game button
                    $('#new-game').click(function() {
                        $('#reset-game').click();
                    });
                }
                return true;
            }
            return false;
        }
        
        // Update board after piece snap
        function onSnapEnd() {
            board.position(game.fen());
        }
        
        // Send the user's move to the server
        function sendMoveToServer(move, position_before) {
            const moveData = {
                move_uci: move.from + move.to + (move.promotion || ''),
                move_san: move.san,
                position_before: position_before, // <-- Use passed value
                position_after: game.fen()
            };
            
            $.ajax({
                url: '/api/game/' + gameId + '/move/',
                type: 'POST',
                data: moveData,
                success: function(data) {
                    displayFeedback(data);
                    updateMoveHistory();
                    if (!game.game_over()) {
                        setTimeout(getAIMove, 1000);
                    }
                },
                error: function(error) {
                    console.error("Error sending move:", error);
                    $('#feedback-container').html('<div class="alert alert-danger">Error analyzing move. Please try again.</div>');
                }
            });
        }
        
        
        // Display feedback for the user's move
        function displayFeedback(data) {
            console.log("Feedback data received:", data);
            const feedback = data.feedback;
            const classification = data.classification;
            const improvement = data.improvement;
            
            let classColor = '';
            switch(classification) {
                case 'best': classColor = 'best-move'; break;
                case 'excellent': classColor = 'excellent-move'; break;
                case 'good': classColor = 'good-move'; break;
                case 'inaccuracy': classColor = 'inaccuracy-move'; break;
                case 'mistake': classColor = 'mistake-move'; break;
                case 'blunder': classColor = 'blunder-move'; break;
                default: classColor = 'normal-move';
            }
            
            let feedbackHtml = `
                <div class="d-flex align-items-center mb-2">
                    <span class="move-quality-indicator" style="background-color: var(--bs-${classColor.split('-')[0]})"></span>
                    <span class="${classColor} text-capitalize">${classification}</span>
                </div>
                <div class="move-analysis">${feedback}</div>
            `;
            
            if (improvement) {
                feedbackHtml += `<div class="improvement-suggestion">${improvement}</div>`;
            }
            
            $('#feedback-container').removeClass('d-none').html(feedbackHtml);
        }
        
        // Get AI move from server
        function getAIMove() {
            // Show typing indicator in chat
            const typingIndicator = $('<div class="typing-indicator"><span></span><span></span><span></span> AI is thinking...</div>');
            $('#chat-messages').append(typingIndicator);
            $('#chat-messages').scrollTop($('#chat-messages')[0].scrollHeight);
            
            $.ajax({
                url: '/api/game/' + gameId + '/ai_move/',
                type: 'GET',
                success: function(data) {
                    // Remove typing indicator
                    $('.typing-indicator').remove();
                    
                    if (data.status === 'success') {
                        // Make the move on the board
                        try {
                            const move = game.move(data.move);
                            board.position(game.fen());
                            
                            // Add AI explanation to chat
                            const explanation = data.feedback || `I played ${data.move}.`;
                            $('#chat-messages').append(`<div class="ai-message">${explanation}</div>`);
                            $('#chat-messages').scrollTop($('#chat-messages')[0].scrollHeight);
                            
                            // Update move history
                            updateMoveHistory();
                            
                            // Check if the game is over after AI move
                            if (!checkGameOver()) {
                                // Now it's user's turn if game is not over
                                userTurn = true;
                            }
                        } catch (error) {
                            console.error("Error applying AI move:", error);
                            $('#chat-messages').append(`<div class="ai-message">Sorry, I encountered an error making my move. Let's try again.</div>`);
                        }
                    } else {
                        $('#chat-messages').append(`<div class="ai-message">Sorry, I couldn't generate a move. Let's try again.</div>`);
                    }
                },
                error: function(error) {
                    // Remove typing indicator
                    $('.typing-indicator').remove();
                    
                    console.error("Error getting AI move:", error);
                    $('#chat-messages').append(`<div class="ai-message">Sorry, there was an error connecting to the server.</div>`);
                }
            });
        }
        
        // Update the move history display
        function updateMoveHistory() {
            $.ajax({
                url: '/api/game/' + gameId + '/move_history/',
                type: 'GET',
                success: function(data) {
                    const moveHistory = $('#move-history');
                    moveHistory.empty();
                    if (data.status === 'success') {
                        data.moves.forEach(function(move) {
                            const label = move.player === 'user' ? 'User' : 'AI';
                            const badgeClass = label === 'User' ? 'bg-primary' : 'bg-secondary';
                            moveHistory.append(
                                `<div class="move-row">
                                    <span class="move-number">${move.move_number}.</span>
                                    <span class="move-label badge ${badgeClass}">${label}</span>
                                    <span class="move-san">${move.move_san}</span>
                                </div>`
                            );
                        });
                    }
                }
            });
        }
        
        // Handle flip board button
        $('#flip-board').click(function() {
            board.flip();
        });
        
        // Handle reset game button
        $('#reset-game').click(function() {
            if (confirm('Are you sure you want to reset the game?')) {
                $.ajax({
                    url: '/api/game/' + gameId + '/reset/',
                    type: 'POST',
                    success: function(data) {
                        // Reset chess.js game
                        game = new Chess();
                        
                        // Reset board
                        board.position('start');
                        
                        // Reset move history
                        $('#move-history').empty();
                        
                        // Reset feedback
                        $('#feedback-container').addClass('d-none');
                        
                        // Clear existing chat messages except the welcome message
                        const welcomeMessage = $('#chat-messages .ai-message').first().clone();
                        $('#chat-messages').empty().append(welcomeMessage);
                        
                        // Add reset message to chat
                        $('#chat-messages').append('<div class="ai-message">Game has been reset. Let\'s start again!</div>');
                        $('#chat-messages').scrollTop($('#chat-messages')[0].scrollHeight);
                        
                        // Set user turn based on color
                        userTurn = (userColor === 'white');
                        
                        // If AI's turn, get move
                        if (!userTurn && !game.game_over()) {
                            setTimeout(getAIMove, 1000);
                        }
                    },
                    error: function(error) {
                        console.error("Error resetting game:", error);
                        alert('Error resetting game. Please try again.');
                    }
                });
            }
        });
        
        // Handle hint button
        $('#hint-button').click(function() {
            const message = 'Can I get a hint?';
            const endpoint = '/api/ask_question/';
            const payload = { message, fen: game.fen() };

            console.log('Sending hint request to:', endpoint);
            console.log('Payload:', payload);

            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify(payload),
            })
            .then(response => response.json())
            .then(data => {
                const chat = $('#chat-messages');
                const messageDiv = $('<div class="ai-message"><strong>Hint:</strong> ').text(data.response);
                chat.append(messageDiv);
                chat.scrollTop(chat[0].scrollHeight);
            });
        });
        
        function formatAIResponse(response) {
            // Example formatting logic
            return response.replace(/\*/g, '').replace(/\n/g, '<br>');
        }

        // Handle chat input
        $('#chat-input').keypress(function(event) {
            if (event.which === 13) { // Enter key
                event.preventDefault();
                $('#send-message').click();
            }
        });

        $('#send-message').click(function() {
            const message = $('#chat-input').val().trim();
            if (message === '') return;

            // Use the correct chat endpoint
            const endpoint = '/api/game/' + gameId + '/chat/';
            const payload = { message: message };

            console.log('Sending request to:', endpoint);
            console.log('Payload:', payload);

            // Display user message
            const chat = $('#chat-messages');
            const userMessageDiv = $('<div class="user-message">').text(message);
            chat.append(userMessageDiv);

            // Clear input field
            $('#chat-input').val('');

            fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken'),
                },
                body: JSON.stringify(payload),
            })
            .then(response => response.json())
            .then(data => {
                const aiMessageDiv = $('<div class="ai-message">').html(formatAIResponse(data.response));
                chat.append(aiMessageDiv);
                chat.scrollTop(chat[0].scrollHeight);
            });
        });

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Resize board on window resize
        $(window).resize(function() {
            board.resize();
        });
    });
</script>
{% endblock %} 